'''Module for handling structures from DICOM files.

Types, Classes and utility function definitions.

'''
# %% Imports
# Type imports

from collections.abc import Hashable
from typing import Any, ClassVar, Dict, NewType, Union, Tuple
from dataclasses import dataclass

# Shared Packages
import shapely
import networkx as nx

# %% Type definitions and Globals
# Index to structures defined in Structure RT DICOM file
ROI_Type = NewType('ROI_Type', int)  # pylint: disable=invalid-name

# The offset in cm between a given image slice and the DICOm origin in the
# `Z` direction.        intp_node_label = (node_data['roi'], new_slice, intp_poly.wkt)
SliceIndexType = NewType('SliceIndexType', float)

# The reference numbers for two different structures to be compared.
StructurePairType = NewType('StructurePairType', Tuple[ROI_Type, ROI_Type])

# Global Settings
PRECISION = 3

# Exception Types
class StructuresException(Exception):
    '''Base class for exceptions in this module.'''

class InvalidContour(ValueError, StructuresException):
    '''Exception raised for invalid contour data.'''

class InvalidContourRelation(ValueError, StructuresException):
    '''Exception raised for invalid contour relationship data.'''

@dataclass
class SliceNeighbours:
    this_slice: SliceIndexType
    previous_slice: SliceIndexType
    next_slice: SliceIndexType

    def is_neighbour(self, other_slice: SliceIndexType) -> bool:
        return self.previous_slice <= other_slice <= self.next_slice

    def gaps(self) -> Union[int, float]:
        return abs(self.next_slice - self.previous_slice) / 2


# RegionGraph is a nx.Graph object with RegionType nodes.
# The edges indicate matching regions on neighbouring slices.
RegionGraph = NewType('RegionGraph', nx.Graph)

# A RegionIndexType is used as a locator for nodes in a region graph.
RegionIndexType = NewType('RegionIndexType',
                          Tuple[ROI_Type, SliceIndexType, Hashable])

# A RegionNodeType is a node from a RegionGraph.  In most ways it can be
# treated as a dictionary generated by the RegionNode `asdict()` method.
RegionNodeType = NewType('RegionNodeType', Dict[str, Any])

@dataclass
class RegionNode:
    # RegionType is a node in a region graph.
    # The node will have the following attributes:
    #  - polygon: shapely.Polygon,0
    #  - roi: ROI_Type,
    #  - slice_index: SliceIndexType,
    #  - is_hole: bool,
    #  - is_boundary: bool,
    #  - is_interpolated: bool,
    #  - is_empty: bool,
    #  - slice_neighbours: SliceNeighbours
    roi: ROI_Type
    slice_index: SliceIndexType
    slice_neighbours: SliceNeighbours
    polygon: shapely.Polygon = shapely.geometry.Polygon()
    is_hole: bool = False
    is_boundary: bool = False
    is_interpolated: bool = False
    is_empty: bool = True
    counter: ClassVar = 0

    def __post_init__(self) -> None:
        self.force_types()
        self.index = RegionNode.counter
        RegionNode.counter += 1

    def force_types(self):
        self.roi = ROI_Type(int(self.roi))
        self.slice_index = SliceIndexType(float(self.slice_index))

    def node_label(self) -> RegionIndexType:
        # A RegionIndexType is used as a locator for nodes in a region graph.
        # The index is a tuple of:
        #   - The Region's ROI number,
        #   - The Region's The slice index,
        #   - An indexer value to force unique nodes.
        return (int(self.roi), float(self.slice_index), int(self.index))

    def add_node(self, graph: RegionGraph) -> None:
        graph.add_node(self.node_label(),
                       polygon=self.polygon,
                       roi=self.roi,
                       slice_index=self.slice_index,
                       is_hole=self.is_hole,
                       is_boundary=self.is_boundary,
                       is_interpolated=self.is_interpolated,
                       is_empty=self.is_empty,
                       slice_neighbours=self.slice_neighbours)

    def reset(self) -> None:
        self.polygon = shapely.geometry.Polygon()
        self.is_empty = True
        self.is_hole: bool = False
        self.is_boundary: bool = False
        self.is_interpolated: bool = False
